<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
  <canvas id="ecgCanvas" width="1000" height="400"></canvas>

  <script>
  const canvas = document.getElementById('ecgCanvas');
  const ctx = canvas.getContext('2d');
  const margin = 60;
  const leadColor = '#2c3e50'; // 导联线颜色
  const waveColors = {
    P: '#3498db',   // 蓝色
    Q: '#2980b9',   // 深蓝
    R: '#e74c3c',   // 红色
    S: '#27ae60',   // 绿色
    T: '#9b59b6'    // 紫色
  };
  
  // 医学标准参数
  const ECGParams = {
    baseHR: 60,      // 心率(bpm)
    amplitude: 0.8,  // mV
    paperSpeed: 25,  // mm/s
    scale: {
      time: 40,      // 40px = 0.2s (25mm/s * 0.2s = 5mm)
      voltage: 20    // 20px = 0.1mV
    }
  };
  
  // 生成符合医学标准的心电数据
  function generateMedicalECG() {
    let x = margin;
    const baseline = canvas.height/2;
    const points = [];
  
    // P波（心房除极）
    points.push(...generateWave(x, baseline, 0.1, 0.25, 60, waveColors.P));
    x += ECGParams.scale.time * 0.8;
  
    // PR段
    points.push(...generateSegment(x, baseline, 0.12, 0));
    x += ECGParams.scale.time * 0.6;
  
    // QRS复合波（心室除极）
    const qrs = [
      {type: 'Q', amplitude: -0.3, duration: 0.02},
      {type: 'R', amplitude: 1.5, duration: 0.04},
      {type: 'S', amplitude: -0.4, duration: 0.02}
    ];
    
    qrs.forEach(wave => {
      points.push(...generateWave(x, baseline, wave.amplitude, wave.duration, 80, waveColors[wave.type]));
      x += ECGParams.scale.time * (wave.duration / 0.2);
    });
  
    // ST段
    points.push(...generateSegment(x, baseline, 0.12, 0.1));
    x += ECGParams.scale.time * 0.6;
  
    // T波（心室复极）
    points.push(...generateWave(x, baseline, 0.3, 0.24, 40, waveColors.T));
    
    return points;
  }
  
  // 生成波形段
  function generateWave(startX, baseline, amp, duration, slope, color) {
    const points = [];
    const steps = duration / 0.02; // 每20ms一个点
    const dx = (ECGParams.scale.time * duration) / steps;
  
    for(let i=0; i<=steps; i++){
      const t = i/steps;
      const y = baseline + (-amp * ECGParams.scale.volt) * Math.sin(Math.PI * t) * (1 + slope/100 * t);
      points.push({
        x: startX + dx * i,
        y: y,
        type: color
      });
    }
    return points;
  }
  
  // 生成水平段
  function generateSegment(startX, baseline, duration, elevation) {
    const points = [];
    const endX = startX + ECGParams.scale.time * (duration / 0.2);
    for(let x=startX; x<=endX; x+=2){
      points.push({
        x: x,
        y: baseline + elevation * ECGParams.scale.volt,
        type: leadColor
      });
    }
    return points;
  }
  
  // 绘制心电图
  function drawECG(points) {
    let currentColor = leadColor;
    
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    
    points.forEach((point, i) => {
      if(point.type !== currentColor) {
        ctx.strokeStyle = currentColor;
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(points[i-1].x, points[i-1].y);
        currentColor = point.type;
      }
      ctx.lineTo(point.x, point.y);
    });
    
    ctx.strokeStyle = currentColor;
    ctx.stroke();
  }
  
  // 专业标注系统
  function drawLabels() {
    const labelPos = {
      P: {x: margin + 80, y: canvas.height/2 - 50},
      Q: {x: margin + 180, y: canvas.height/2 + 40},
      R: {x: margin + 220, y: canvas.height/2 - 80},
      S: {x: margin + 260, y: canvas.height/2 + 50},
      T: {x: margin + 400, y: canvas.height/2 - 60}
    };
  
    Object.entries(waveColors).forEach(([wave, color]) => {
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(labelPos[wave].x, labelPos[wave].y);
      ctx.lineTo(labelPos[wave].x + 20, labelPos[wave].y - 20);
      ctx.stroke();
      
      ctx.fillStyle = color;
      ctx.font = 'bold 14px Arial';
      ctx.fillText(wave, labelPos[wave].x + 22, labelPos[wave].y - 22);
    });
  }
  
  // 绘制医学网格
  function drawMedicalGrid() {
    ctx.strokeStyle = '#ecf0f1';
    ctx.lineWidth = 1;
    
    // 粗网格（0.2s / 0.5mV）
    for(let x=margin; x<canvas.width; x+=ECGParams.scale.time*5){
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(x, margin);
      ctx.lineTo(x, canvas.height-margin);
      ctx.stroke();
    }
    
    // 细网格（0.04s / 0.1mV）
    ctx.setLineDash([2, 2]);
    for(let x=margin; x<canvas.width; x+=ECGParams.scale.time){
      ctx.beginPath();
      ctx.moveTo(x, margin);
      ctx.lineTo(x, canvas.height-margin);
      ctx.stroke();
    }
  }
  
  // 坐标轴系统
  function drawAxis() {
    ctx.strokeStyle = '#7f8c8d';
    ctx.setLineDash([]);
    
    // Y轴（电压）
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, canvas.height-margin);
    
    // X轴（时间）
    ctx.moveTo(margin, canvas.height/2);
    ctx.lineTo(canvas.width-margin, canvas.height/2);
    ctx.stroke();
    
    // 刻度标签
    ctx.fillStyle = '#95a5a6';
    ctx.font = '12px Arial';
    for(let t=0; t<=3; t+=0.2){
      const x = margin + t * ECGParams.scale.time * 5;
      ctx.fillText(`${t}s`, x-10, canvas.height-20);
    }
  }
  
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawMedicalGrid();
    drawAxis();
    
    const ecgData = generateMedicalECG();
    ctx.lineWidth = 2;
    drawECG(ecgData);
    drawLabels();
  }
  
  draw();
  </script>


    
</body>
</html>